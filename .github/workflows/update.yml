# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Update Dependencies

on:
    workflow_dispatch:
        inputs:
            auto-merge:
                description: "Auto-merge PR if checks pass"
                type: boolean
                required: false
                default: true
    schedule:
        # Run every Friday at 4 AM UTC
        - cron: "0 4 * * 5"

run-name: Update npins and flake inputs

permissions:
    contents: write
    pull-requests: write
    checks: read

env:
    GIT_USERNAME: github-actions[bot]
    GIT_EMAIL: github-actions[bot]@users.noreply.github.com

jobs:
    update-dependencies:
        runs-on: ubuntu-latest
        steps:
            - name: Validate Required Secrets
              env:
                  PAT_TOKEN: ${{ secrets.PAT }}
              run: |
                  # Check PAT
                  if [ -z "${PAT_TOKEN}" ]; then
                    echo "::error::PAT secret is not configured"
                    echo "::error::This workflow requires a Personal Access Token (PAT) to:"
                    echo "::error::  1. Create pull requests that trigger CI workflows"
                    echo "::error::  2. Enable auto-merge on pull requests"
                    echo "::error::  3. Access GitHub packages via Nix"
                    echo "::error::"
                    echo "::error::To configure PAT:"
                    echo "::error::  1. Create token at: https://github.com/settings/tokens/new"
                    echo "::error::  2. Required scopes: 'repo', 'workflow'"
                    echo "::error::  3. Add to repository secrets as 'PAT'"
                    echo "::error::  4. Location: https://github.com/${{ github.repository }}/settings/secrets/actions"
                    exit 1
                  fi

                  echo "‚úÖ PAT secret is configured"

            - name: Checkout repository
              uses: actions/checkout@v6
              with:
                  token: ${{ secrets.PAT }}

            - name: Setup SSH known hosts
              run: |
                  mkdir -p ~/.ssh
                  ssh-keyscan git.polarmutex.dev >> ~/.ssh/known_hosts

            - name: Setup SSH agent
              uses: webfactory/ssh-agent@v0.9.0
              with:
                  ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

            - name: Install Nix
              uses: cachix/install-nix-action@v31
              with:
                  extra_nix_config: |
                      experimental-features = nix-command flakes pipe-operators
                      accept-flake-config = true
                      access-tokens = github.com=${{ secrets.PAT }}

            - name: Configure Git
              run: |
                  git config --local user.email "${{ env.GIT_EMAIL }}"
                  git config --local user.name "${{ env.GIT_USERNAME }}"

            - name: Capture versions before update
              id: capture-before
              run: |
                  # Capture flake inputs before update
                  echo "Capturing current flake.lock state..."
                  nix flake metadata --json | jq -r '.locks.nodes | with_entries(if .value.locked then .value = .value.locked.rev // .value.locked.narHash // "unknown" else empty end)' > /tmp/before-inputs.json

                  # Capture npins sources before update
                  echo "Capturing current npins state..."
                  jq -r '.pins | to_entries[] | "\(.key)=\(.value.revision // .value.version // "unknown")"' npins/sources.json > /tmp/before-npins.txt

                  # Capture neovim plugins before update
                  if [ -f packages/neovim/start.json ]; then
                    jq -r '.pins | to_entries[] | "\(.key)=\(.value.revision // .value.version // "unknown")"' packages/neovim/start.json > /tmp/before-neovim-start.txt
                  fi

                  if [ -f packages/neovim/opt.json ]; then
                    jq -r '.pins | to_entries[] | "\(.key)=\(.value.revision // .value.version // "unknown")"' packages/neovim/opt.json > /tmp/before-neovim-opt.txt
                  fi

                  echo "Current state captured"

            - name: Update all npins in parallel
              id: npins-update
              timeout-minutes: 10
              run: |
                  echo "Updating all npins sources in parallel..."

                  # Update root npins in background
                  (
                    echo "Updating root npins sources..."
                    nix run nixpkgs#npins -- update
                  ) &
                  PID1=$!

                  # Update neovim start plugins in background
                  (
                    echo "Updating neovim start plugins..."
                    cd packages/neovim
                    nix run .#npins -- --lock-file ./start.json update -f 2>&1 | { grep '.*Changes:$\|.*url:.*' || true; }
                  ) &
                  PID2=$!

                  # Update neovim opt plugins in background
                  (
                    echo "Updating neovim opt plugins..."
                    cd packages/neovim
                    nix run .#npins -- --lock-file ./opt.json update -f 2>&1 | { grep '.*Changes:$\|.*url:.*' || true; }
                  ) &
                  PID3=$!

                  # Wait for all to complete
                  wait $PID1 $PID2 $PID3
                  echo "All npins updates completed"

                  # Check what was updated
                  NPINS_UPDATED=false
                  NEOVIM_START_UPDATED=false
                  NEOVIM_OPT_UPDATED=false

                  if ! git diff --quiet npins/sources.json; then
                    NPINS_UPDATED=true
                  fi

                  if ! git diff --quiet packages/neovim/start.json; then
                    NEOVIM_START_UPDATED=true
                  fi

                  if ! git diff --quiet packages/neovim/opt.json; then
                    NEOVIM_OPT_UPDATED=true
                  fi

                  # Set outputs
                  echo "updated=$NPINS_UPDATED" >> "$GITHUB_OUTPUT"
                  echo "neovim-start-updated=$NEOVIM_START_UPDATED" >> "$GITHUB_OUTPUT"
                  echo "neovim-opt-updated=$NEOVIM_OPT_UPDATED" >> "$GITHUB_OUTPUT"

            - name: Update flake.lock
              id: flake-update
              timeout-minutes: 10
              run: |
                  echo "Starting flake update..."

                  # Update all flake inputs
                  nix flake update 2>&1 | tee /tmp/flake-update.log

                  echo "Flake update completed"

                  if ! git diff --quiet flake.lock; then
                    echo "updated=true" >> "$GITHUB_OUTPUT"
                  else
                    echo "updated=false" >> "$GITHUB_OUTPUT"
                  fi

            - name: Upload flake update log on failure
              if: failure()
              uses: actions/upload-artifact@v6
              with:
                  name: flake-update-log
                  path: /tmp/flake-update.log
                  if-no-files-found: ignore

            - name: Build commit message and commit changes
              id: commit-changes
              run: |
                  # Check if there are any changes
                  if git diff --quiet && git diff --cached --quiet; then
                    echo "No updates to commit"
                    echo "has_changes=false" >> "$GITHUB_OUTPUT"
                    exit 0
                  fi

                  echo "has_changes=true" >> "$GITHUB_OUTPUT"

                  # Determine what was updated
                  HAS_NPINS=false
                  HAS_NEOVIM_START=false
                  HAS_NEOVIM_OPT=false
                  HAS_FLAKE=false

                  if ! git diff --quiet npins/sources.json; then
                    HAS_NPINS=true
                  fi

                  if ! git diff --quiet packages/neovim/start.json; then
                    HAS_NEOVIM_START=true
                  fi

                  if ! git diff --quiet packages/neovim/opt.json; then
                    HAS_NEOVIM_OPT=true
                  fi

                  if ! git diff --quiet flake.lock; then
                    HAS_FLAKE=true
                  fi

                  # Start building commit message
                  COMMIT_MSG="chore: update dependencies"

                  COMMIT_BODY=""

                  # Initialize change tracking files
                  > /tmp/npins-changes.txt
                  > /tmp/neovim-start-changes.txt
                  > /tmp/neovim-opt-changes.txt

                  # Add npins changes if present
                  if [ "$HAS_NPINS" = true ]; then
                    COMMIT_BODY="${COMMIT_BODY}Updated npins sources:\n\n"

                    # Capture after state and compare
                    jq -r '.pins | to_entries[] | "\(.key)=\(.value.revision // .value.version // "unknown")"' npins/sources.json > /tmp/after-npins.txt

                    while IFS='=' read -r pkg after_ver; do
                      before_ver=$(grep "^${pkg}=" /tmp/before-npins.txt | cut -d'=' -f2 || echo "new")
                      if [ "$before_ver" != "$after_ver" ]; then
                        before_short="${before_ver:0:8}"
                        after_short="${after_ver:0:8}"
                        COMMIT_BODY="${COMMIT_BODY}  ${pkg}: ${before_short} -> ${after_short}\n"
                        echo "  ${pkg}: ${before_short} -> ${after_short}" >> /tmp/npins-changes.txt
                      fi
                    done < /tmp/after-npins.txt

                    COMMIT_BODY="${COMMIT_BODY}\n"
                    git add npins/sources.json
                  fi

                  # Add neovim plugin changes if present
                  if [ "$HAS_NEOVIM_START" = true ] || [ "$HAS_NEOVIM_OPT" = true ]; then
                    COMMIT_BODY="${COMMIT_BODY}Updated neovim plugins:\n\n"

                    if [ "$HAS_NEOVIM_START" = true ]; then
                      COMMIT_BODY="${COMMIT_BODY}Start plugins:\n"

                      # Capture after state and compare
                      jq -r '.pins | to_entries[] | "\(.key)=\(.value.revision // .value.version // "unknown")"' packages/neovim/start.json > /tmp/after-neovim-start.txt

                      while IFS='=' read -r pkg after_ver; do
                        before_ver=$(grep "^${pkg}=" /tmp/before-neovim-start.txt | cut -d'=' -f2 || echo "new")
                        if [ "$before_ver" != "$after_ver" ]; then
                          before_short="${before_ver:0:8}"
                          after_short="${after_ver:0:8}"
                          COMMIT_BODY="${COMMIT_BODY}  ${pkg}: ${before_short} -> ${after_short}\n"
                          echo "  ${pkg}: ${before_short} -> ${after_short}" >> /tmp/neovim-start-changes.txt
                        fi
                      done < /tmp/after-neovim-start.txt

                      COMMIT_BODY="${COMMIT_BODY}\n"
                      git add packages/neovim/start.json
                    fi

                    if [ "$HAS_NEOVIM_OPT" = true ]; then
                      COMMIT_BODY="${COMMIT_BODY}Opt plugins:\n"

                      # Capture after state and compare
                      jq -r '.pins | to_entries[] | "\(.key)=\(.value.revision // .value.version // "unknown")"' packages/neovim/opt.json > /tmp/after-neovim-opt.txt

                      while IFS='=' read -r pkg after_ver; do
                        before_ver=$(grep "^${pkg}=" /tmp/before-neovim-opt.txt | cut -d'=' -f2 || echo "new")
                        if [ "$before_ver" != "$after_ver" ]; then
                          before_short="${before_ver:0:8}"
                          after_short="${after_ver:0:8}"
                          COMMIT_BODY="${COMMIT_BODY}  ${pkg}: ${before_short} -> ${after_short}\n"
                          echo "  ${pkg}: ${before_short} -> ${after_short}" >> /tmp/neovim-opt-changes.txt
                        fi
                      done < /tmp/after-neovim-opt.txt

                      COMMIT_BODY="${COMMIT_BODY}\n"
                      git add packages/neovim/opt.json
                    fi
                  fi

                  # Add flake changes if present
                  if [ "$HAS_FLAKE" = true ]; then
                    # Capture after state
                    nix flake metadata --json | jq -r '.locks.nodes | with_entries(if .value.locked then .value = .value.locked.rev // .value.locked.narHash // "unknown" else empty end)' > /tmp/after-inputs.json

                    # Generate version changes
                    COMMIT_BODY="${COMMIT_BODY}Updated flake inputs:\n\n"

                    # Clear version changes file
                    > /tmp/version-changes.txt

                    # Compare before and after
                    jq -r 'keys[]' /tmp/before-inputs.json | while read -r input; do
                      BEFORE_REV=$(jq -r --arg key "$input" 'if .[$key] then .[$key] else "missing" end' /tmp/before-inputs.json)
                      AFTER_REV=$(jq -r --arg key "$input" 'if .[$key] then .[$key] else "missing" end' /tmp/after-inputs.json)

                      if [ "$BEFORE_REV" != "$AFTER_REV" ] && [ "$BEFORE_REV" != "missing" ] && [ "$AFTER_REV" != "missing" ]; then
                        # Truncate revisions for readability
                        BEFORE_SHORT="${BEFORE_REV:0:8}"
                        AFTER_SHORT="${AFTER_REV:0:8}"
                        CHANGE_LINE="  ${input}: ${BEFORE_SHORT} -> ${AFTER_SHORT}\n"
                        COMMIT_BODY="${COMMIT_BODY}${CHANGE_LINE}"
                        # Save to file for PR body (without escape sequences)
                        echo "  ${input}: ${BEFORE_SHORT} -> ${AFTER_SHORT}" >> /tmp/version-changes.txt
                      fi
                    done

                    git add flake.lock
                  fi

                  # Build full commit message
                  {
                    echo "${COMMIT_MSG}"
                    echo ""
                    echo -e "${COMMIT_BODY}"
                  } > /tmp/commit-msg.txt

                  git commit -F /tmp/commit-msg.txt

                  echo "Commit created successfully"

            - name: Create summary
              if: steps.commit-changes.outputs.has_changes == 'true'
              run: |
                  {
                    echo "## Update Summary"
                    echo ""
                    if [ "${{ steps.npins-update.outputs.updated }}" = "true" ]; then
                      echo "‚úÖ npins sources updated"
                    fi
                    if [ "${{ steps.npins-update.outputs.neovim-start-updated }}" = "true" ]; then
                      echo "‚úÖ Neovim start plugins updated"
                    fi
                    if [ "${{ steps.npins-update.outputs.neovim-opt-updated }}" = "true" ]; then
                      echo "‚úÖ Neovim opt plugins updated"
                    fi
                    if [ "${{ steps.flake-update.outputs.updated }}" = "true" ]; then
                      echo "‚úÖ Flake inputs updated"
                    fi
                    echo ""
                    echo "### Changes"
                    echo '```'
                    git log -1 --pretty=format:"%B"
                    echo '```'
                  } >> "$GITHUB_STEP_SUMMARY"

            # - name: Validate builds still work
            #   if: steps.commit-changes.outputs.has_changes == 'true'
            #   timeout-minutes: 15
            #   run: |
            #       echo "Testing that critical packages still build after updates..."
            #
            #       # Test flake check first
            #       echo "Running flake check..."
            #       nix flake check -L --accept-flake-config
            #
            #       # Test critical packages with dry-run (fast)
            #       echo "Validating critical packages..."
            #       nix build .#neovim --dry-run --accept-flake-config
            #       nix build .#blink-cmp --dry-run --accept-flake-config
            #       nix build .#context7-mcp --dry-run --accept-flake-config
            #
            #       echo "‚úÖ All validation checks passed"

            - name: Generate PR body
              if: steps.commit-changes.outputs.has_changes == 'true'
              id: generate-pr-body
              run: |
                  # Start building PR body
                  PR_BODY="## Automated Dependency Update

                  This PR contains automated updates for dependencies.

                  ### Updated"

                  # Add update checkmarks
                  if [ "${{ steps.npins-update.outputs.updated }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  - ‚úÖ npins sources"
                  fi

                  if [ "${{ steps.npins-update.outputs.neovim-start-updated }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  - ‚úÖ Neovim start plugins"
                  fi

                  if [ "${{ steps.npins-update.outputs.neovim-opt-updated }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  - ‚úÖ Neovim opt plugins"
                  fi

                  if [ "${{ steps.flake-update.outputs.updated }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  - ‚úÖ Flake inputs"
                  fi

                  # Add version changes sections
                  CHANGES_ADDED=false

                  # Add npins changes
                  if [ -f /tmp/npins-changes.txt ] && [ -s /tmp/npins-changes.txt ]; then
                    if [ "$CHANGES_ADDED" = false ]; then
                      PR_BODY="${PR_BODY}

                  ### Version Changes"
                      CHANGES_ADDED=true
                    fi
                    PR_BODY="${PR_BODY}

                  #### Npins Sources
                  \`\`\`"
                    PR_BODY="${PR_BODY}
                  $(cat /tmp/npins-changes.txt)"
                    PR_BODY="${PR_BODY}
                  \`\`\`"
                  fi

                  # Add neovim start plugin changes
                  if [ -f /tmp/neovim-start-changes.txt ] && [ -s /tmp/neovim-start-changes.txt ]; then
                    if [ "$CHANGES_ADDED" = false ]; then
                      PR_BODY="${PR_BODY}

                  ### Version Changes"
                      CHANGES_ADDED=true
                    fi
                    PR_BODY="${PR_BODY}

                  #### Neovim Start Plugins
                  \`\`\`"
                    PR_BODY="${PR_BODY}
                  $(cat /tmp/neovim-start-changes.txt)"
                    PR_BODY="${PR_BODY}
                  \`\`\`"
                  fi

                  # Add neovim opt plugin changes
                  if [ -f /tmp/neovim-opt-changes.txt ] && [ -s /tmp/neovim-opt-changes.txt ]; then
                    if [ "$CHANGES_ADDED" = false ]; then
                      PR_BODY="${PR_BODY}

                  ### Version Changes"
                      CHANGES_ADDED=true
                    fi
                    PR_BODY="${PR_BODY}

                  #### Neovim Opt Plugins
                  \`\`\`"
                    PR_BODY="${PR_BODY}
                  $(cat /tmp/neovim-opt-changes.txt)"
                    PR_BODY="${PR_BODY}
                  \`\`\`"
                  fi

                  # Add flake input changes
                  if [ -f /tmp/version-changes.txt ] && [ -s /tmp/version-changes.txt ]; then
                    if [ "$CHANGES_ADDED" = false ]; then
                      PR_BODY="${PR_BODY}

                  ### Version Changes"
                      CHANGES_ADDED=true
                    fi
                    PR_BODY="${PR_BODY}

                  #### Flake Inputs
                  \`\`\`"
                    PR_BODY="${PR_BODY}
                  $(cat /tmp/version-changes.txt)"
                    PR_BODY="${PR_BODY}
                  \`\`\`"
                  fi

                  PR_BODY="${PR_BODY}

                  **Triggered by:** ${{ github.event_name == 'workflow_dispatch' && 'Manual trigger' || 'Scheduled run' }}

                  ---

                  ü§ñ This PR was automatically created by the update workflow."

                  if [ "${{ github.event_name == 'schedule' || inputs.auto-merge }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  üîÑ Will auto-merge when checks pass."
                  fi

                  # Save to file for use in next step
                  echo "$PR_BODY" > /tmp/pr-body.txt

            - name: Generate PR body
              if: steps.commit-changes.outputs.has_changes == 'true'
              id: generate-pr-body
              run: |
                  # Start building PR body
                  PR_BODY="## Automated Dependency Update

                  This PR contains automated updates for dependencies.

                  ### Updated"

                  # Add update checkmarks
                  if [ "${{ steps.npins-update.outputs.updated }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  - ‚úÖ npins sources"
                  fi

                  if [ "${{ steps.npins-update.outputs.neovim-start-updated }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  - ‚úÖ Neovim start plugins"
                  fi

                  if [ "${{ steps.npins-update.outputs.neovim-opt-updated }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  - ‚úÖ Neovim opt plugins"
                  fi

                  if [ "${{ steps.flake-update.outputs.updated }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  - ‚úÖ Flake inputs"
                  fi

                  # Add version changes sections
                  CHANGES_ADDED=false

                  # Add npins changes
                  if [ -f /tmp/npins-changes.txt ] && [ -s /tmp/npins-changes.txt ]; then
                    if [ "$CHANGES_ADDED" = false ]; then
                      PR_BODY="${PR_BODY}

                  ### Version Changes"
                      CHANGES_ADDED=true
                    fi
                    PR_BODY="${PR_BODY}

                  #### Npins Sources
                  \`\`\`"
                    PR_BODY="${PR_BODY}
                  $(cat /tmp/npins-changes.txt)"
                    PR_BODY="${PR_BODY}
                  \`\`\`"
                  fi

                  # Add neovim start plugin changes
                  if [ -f /tmp/neovim-start-changes.txt ] && [ -s /tmp/neovim-start-changes.txt ]; then
                    if [ "$CHANGES_ADDED" = false ]; then
                      PR_BODY="${PR_BODY}

                  ### Version Changes"
                      CHANGES_ADDED=true
                    fi
                    PR_BODY="${PR_BODY}

                  #### Neovim Start Plugins
                  \`\`\`"
                    PR_BODY="${PR_BODY}
                  $(cat /tmp/neovim-start-changes.txt)"
                    PR_BODY="${PR_BODY}
                  \`\`\`"
                  fi

                  # Add neovim opt plugin changes
                  if [ -f /tmp/neovim-opt-changes.txt ] && [ -s /tmp/neovim-opt-changes.txt ]; then
                    if [ "$CHANGES_ADDED" = false ]; then
                      PR_BODY="${PR_BODY}

                  ### Version Changes"
                      CHANGES_ADDED=true
                    fi
                    PR_BODY="${PR_BODY}

                  #### Neovim Opt Plugins
                  \`\`\`"
                    PR_BODY="${PR_BODY}
                  $(cat /tmp/neovim-opt-changes.txt)"
                    PR_BODY="${PR_BODY}
                  \`\`\`"
                  fi

                  # Add flake input changes
                  if [ -f /tmp/version-changes.txt ] && [ -s /tmp/version-changes.txt ]; then
                    if [ "$CHANGES_ADDED" = false ]; then
                      PR_BODY="${PR_BODY}

                  ### Version Changes"
                      CHANGES_ADDED=true
                    fi
                    PR_BODY="${PR_BODY}

                  #### Flake Inputs
                  \`\`\`"
                    PR_BODY="${PR_BODY}
                  $(cat /tmp/version-changes.txt)"
                    PR_BODY="${PR_BODY}
                  \`\`\`"
                  fi

                  PR_BODY="${PR_BODY}

                  **Triggered by:** ${{ github.event_name == 'workflow_dispatch' && 'Manual trigger' || 'Scheduled run' }}

                  ---

                  ü§ñ This PR was automatically created by the update workflow."

                  if [ "${{ github.event_name == 'schedule' || inputs.auto-merge }}" = "true" ]; then
                    PR_BODY="${PR_BODY}
                  üîÑ Will auto-merge when checks pass."
                  fi

                  # Save to file for use in next step
                  echo "$PR_BODY" > /tmp/pr-body.txt

            - name: Create Pull Request
              if: steps.commit-changes.outputs.has_changes == 'true'
              id: create-pr
              uses: peter-evans/create-pull-request@v8
              with:
                  token: ${{ secrets.PAT }}
                  branch: automated-flake-update
                  delete-branch: true
                  title: "chore: update dependencies"
                  body-path: /tmp/pr-body.txt
                  labels: |
                      dependencies
                      automated
                  draft: false

            - name: Enable auto-merge
              if: |
                  steps.create-pr.outputs.pull-request-number &&
                  (github.event_name == 'schedule' || inputs.auto-merge)
              continue-on-error: true
              env:
                  GH_TOKEN: ${{ secrets.PAT }}
                  PR_NUMBER: ${{ steps.create-pr.outputs.pull-request-number }}
              run: |
                  echo "Attempting to enable auto-merge for PR #${PR_NUMBER}"
                  echo ""
                  echo "‚ÑπÔ∏è  Auto-merge will wait for the following before merging:"
                  echo "  - Required status checks configured in branch protection"
                  echo ""

                  if gh pr merge "${PR_NUMBER}" --auto --squash --delete-branch 2>&1; then
                    echo "‚úÖ Auto-merge enabled successfully"
                  else
                    echo "‚ö†Ô∏è  Auto-merge is not enabled for this repository"
                    echo ""
                    echo "To enable auto-merge:"
                    echo "  1. Go to: https://github.com/${{ github.repository }}/settings"
                    echo "  2. Scroll to 'Pull Requests'"
                    echo "  3. Check 'Allow auto-merge'"
                    echo ""
                    echo "PR created successfully but will require manual merge."
                    exit 0
                  fi
